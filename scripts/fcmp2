#!/usr/bin/env python3

DEFAULT_LOCATOR_0=True # Set locator 0 if unset
ADD_DEBUG_INFO=False

import sys, json, os
from repr_ja import *

_prog=os.path.split(os.path.realpath(__file__))[1]
HELP_MESSAGE=sys.argv[0] + '''

NAME
	''' + _prog + '''

SYNOPSIS
	''' + _prog + ''' IN OUT BINFO
	''' + _prog + ''' --help

DESCRIPTION
	Generate cpp blocks for given ja program (IN) and save it
	to OUT. Blocks info is saved to BINFO

OPTIONS
	--help
	    Show this help and exit

'''

BLOCKH='// %s\nBlockRetStatus block_%d(CF &self)\n{\n'
C_TYPE={
	'int': 'int',
	'real': 'double',
	'string': 'const char *',
	'value': 'const InputDF &',
	'name': 'OutputDF &'
}
C_VALUE_TYPE={
	'int': 'TYPE_INT',
	'real': 'TYPE_REAL',
	'string': 'TYPE_STRING',
	'value': 'TYPE_VALUE',
	'name': 'TYPE_NAME'
}

class CompileError(Exception):
	def __init__(self, msg, pos):
		self.Msg=msg
		self.Pos=pos


VERBOSE=False

def REM(msg):
	res=''
	if VERBOSE:
		res+='printf("' + quote(msg) + ' @ %s:%d\\n", __FILE__, __LINE__); '
	res+='// %s' % quote(msg)
	return res

cpp_blocks_info={}

gid=0
def gen_id(pos, comment=''):
	global gid, cpp_blocks_info
	assert gid not in cpp_blocks_info
	cpp_blocks_info[gid]={
		'pos': pos
	}
	if comment:
		cpp_blocks_info[gid]['comment']=comment
	gid+=1
	return gid-1

sub_blocks={}
def get_sub_block(sub_name):
	if sub_name not in sub_blocks:
		sub=gja[sub_name]
		pos=sub['begin']
		sub_blocks[sub_name]=gen_id(pos, 'sub %s' % sub_name)
	return sub_blocks[sub_name]


def create_scope(j, parent):
	scope={
		'args': [],
		'ids': [],
		'dfs': [],
		'cfs': [],
		'children': [],
		'j': j,
		'parent': parent,
		'create_ids': [],
		'names': {},
		'values': {}
	}
	if parent:
		parent['children'].append(scope)
	return scope

def ps(scope):
	for k, v in scope.items():
		if k in ['j', 'parent', 'children']:
			continue
		print('%s=%s' % (k, repr(v)))

class UnresolvedName(Exception):
	def __init__(self, *args, **kwargs):
		Exception.__init__(self, *args, **kwargs)

def is_base_sub_param(name, j):
	if j['type']!='struct':
		return False
	params=j['args']
	for param in params:
		if 'id' not in param:
			R(param)
		if param['id']==name and param['type'] in ['int', 'real',
				'string']:
			return True
	else:
		return False

def resolve_id(name, scope):
	if scope is None:
		raise UnresolvedName(name)
	if name in scope['names']:
		return scope['names'][name]

	if name in scope['dfs'] or name in scope['cfs']:
		id='_id_%d' % len(scope['create_ids'])
		scope['names'][name]=id
		scope['create_ids'].append((id, name))
		return resolve_id(name, scope)

	if is_base_sub_param(name, scope['j']):
		raise UnresolvedName('Attempting to access basic type as name',
			name)

	res=resolve_id(name, scope['parent'])
	arg=len(scope['ids'])
	if type(res)!=str:
		R(res, name)
	assert type(res)==str
	scope['ids'].append(res)
	scope['names'][name]='self.id(%d)' % arg
	return resolve_id(name, scope)

def resolve_value(name, scope):
	if scope is None:
		raise UnresolvedName(name)
	if name in scope['values']:
		return scope['values'][name]

	try:
		res=resolve_id(name, scope)
		scope['values'][name]={
			'snip': 'self.wait(%s)' % res,
			'type': 'value'
		}
		return resolve_value(name, scope)
	except UnresolvedName:
		pass

	res=resolve_value(name, scope['parent'])
	arg=len(scope['args'])
	scope['args'].append(res['snip'])
	if res['type']=='string':
		snip='self.arg(%d).get_string()' % arg
	elif res['type']=='int':
		snip='self.arg(%d).get_int()' % arg
	elif res['type']=='real':
		snip='self.arg(%d).get_real()' % arg
	else:
		R(res)
	scope['values'][name]={
		'snip': snip,
		'type': res['type']
	}
	return resolve_value(name, scope)

def locator(id, scope, rules_scope=None):
	if rules_scope is None:
		rules_scope=scope
	for r in rules_scope['j'].get('rules', []):
		if r['ruletype']=='map' \
				and r['property']=='locator_cyclic':
			if r['id'][0]!=id[0]:
				continue
			assert len(r['id'])==len(id)
			if id[1:]:
				old_values=json.dumps(scope['values'])
				for i in range(len(id[1:])):
					assert not r['id'][i+1]['ref'][1:]
					var=r['id'][i+1]['ref'][0]
					val=value_int(id[i+1], scope)
					scope['values'][var]={
						'snip': val,
						'type': 'int'
					}
				res='CyclicLocator(%s)' % value_int(r['expr'], scope)
				scope['values']=json.loads(old_values)
				return res
			else:
				return 'CyclicLocator(%s)' % value_int(r['expr'], scope)

	if rules_scope['parent'] is None:
		if DEFAULT_LOCATOR_0:
			return 'CyclicLocator(0)'
		else:
			raise UnresolvedName(id)
	return locator(id, scope, rules_scope['parent'])

def oper_type(operands):
	res=None
	for o in operands:
		if res is None:
			res=o
		elif res==o:
			pass
		elif res=='int' and o=='real':
			res='real'
		elif o=='value':
			pass
		elif res=='real' and o in ['int', 'real']:
			pass
		elif res=='value' and o in ['int', 'real']:
			res=o
		else:
			R(res, operands, o)
	assert res is not None
	return res

def expr_type(x, scope):
	if x['type'] in ['iconst', 'icast', '%']:
		return 'int'
	elif x['type'] in ['rconst', 'rcast']:
		return 'real'
	elif x['type'] in ['sconst', 'scast']:
		return 'string'
	elif x['type'] in ['+', '-', '*', '/']:
		return oper_type([expr_type(op, scope) \
			for op in x['operands']])
	elif x['type']=='id':
		if not x['ref'][1:]:
			res=resolve_value(x['ref'][0], scope)
			return res['type']
		else:
			return 'value'
	elif x['type'] in ['<', '<=', '==', '!=', '>=', '>', '&&', '||', '?:']:
		return 'int'
	else:
		R(x, x['type'])

def gen_formula(x, scope, dest_value_type):
	ops=[]
	oxt=oper_type([expr_type(op, scope) for op in x['operands']])

	if oxt=='string':
		if x['type'] not in ['+', '!=', '==']:
			raise CompileError('invalid operation on strings: %s' % \
				x['type'], x['op_pos'])
		for op in x['operands']:
			ops.append(value_string(op, scope))
		if x['type']=='+':
			return '(' + x['type'].join(['std::string(%s)' % s \
				for s in ops]) + ')'
		elif x['type'] in ['!=', '==']:
			assert len(ops)==2
			return '(std::string(%s) %s std::string(%s))' \
				% (ops[0], x['type'], ops[1])
		else:
			R(x)


	for op in x['operands']:
		xt=expr_type(op, scope)
		if xt in ['int', 'real']:
			ops.append(value(op, scope, expr_type(op, scope)))
		elif xt=='value' and oxt!='value':
			ops.append(value(op, scope, oxt))
		elif xt=='value' and oxt=='value':
			ops.append(value_value(op, scope))
		elif xt=='string' and oxt=='string':
			ops.append(value_string(op, scope))
		else:
			R(op, xt, oxt)

	if x['type']=='?:':
		return '((%s)?(%s):(%s))' % (ops[0], ops[1], ops[2])

	formula=x['type'].join(['(%s)' % op for op in ops])

	if oxt=='value':
		if dest_value_type in ['int', 'real']:
			return '(%s).get_%s()' % (formula, dest_value_type)
		elif dest_value_type=='value':
			return formula
		else:
			R(dest_value_type, formula)
	else:
		return formula

def value_int(x, scope):
	if x['type']=='iconst':
		return '%d' % x['value']
	elif x['type']=='rconst':
		return 'static_cast<int>(%lf)' % x['value']
	elif x['type']=='icast':
		return value_int(x['expr'], scope)
	elif x['type']=='rcast':
		return 'static_cast<int>(%s)' \
                    % value_real(x['expr'], scope)
	elif x['type']=='sconst':
		raise NotImplementedError("Need quotation", x['value'], c)
	elif x['type']=='id':
		if not x['ref'][1:]:
			res=resolve_value(x['ref'][0], scope)
			if res['type']=='int':
				return res['snip']
			elif res['type']=='value':
				return '(%s).get_int()' % res['snip']
			else:
				R(res)
		return 'self.wait(%s).get_int()' % ref1(x['ref'], scope)
	elif x['type'] in ['+', '-', '*', '/', '%']:
		return 'static_cast<int>(%s)' % gen_formula(x, scope,
                    'int')
	elif x['type'] in ['<', '<=', '==', '!=', '>=', '>',
			'&&', '||', '?:']:
		return 'static_cast<int>(%s)' % gen_formula(x, scope, 'int')
	elif x['type']=='?:':
		raise NotImplementedError(x['type'])
		assert len(x['operands'])==3
		return '((%s)?(%s):(%s))' % (
			value(x['operands'][0], scope),
			value(x['operands'][1], scope),
			value(x['operands'][2], scope)
		)
	else:
		R(x)

def value_real(x, scope):
	if x['type']=='rconst':
		return '%lf' % x['value']
	elif x['type']=='rcast':
		return '%s' % value_real(x['expr'], scope)
	elif x['type']=='iconst':
		return 'static_cast<double>(%d)' % x['value']
	elif x['type']=='icast':
		return 'static_cast<double>(%s)' % value_int(x['expr'], scope)
	elif x['type'] in ['+', '-', '*', '/']:
		return 'static_cast<double>(%s)' % gen_formula(x, scope, 'real')
	elif x['type'] in ['<', '<=', '==', '!=', '>=', '>',
			'&&', '||']:
		return 'static_cast<double>(%s)' % gen_formula(x, scope, 'int')
	elif x['type']=='?:':
		return 'static_cast<double>(0!=%s? %s: %s)' % (
			value_int(x['operands'][0], scope),
			value(x['operands'][1], scope,
				expr_type(x['operands'][1], scope)),
			value(x['operands'][2], scope,
				expr_type(x['operands'][2], scope))
		)
	elif x['type']=='id':
		if not x['ref'][1:]:
			res=resolve_value(x['ref'][0], scope)
			if res['type']=='real':
				return res['snip']
			elif res['type']=='value':
				return '(%s).get_real()' % res['snip']
			else:
				R(res)
		else:
			return 'self.wait(%s).get_real()' \
				% ref1(x['ref'], scope)
	else:
		R(x, x['type'])

	raise Exception("this is unreachable?")
	t=expr_type(x, scope)
	if t=='int':
		return 'static_cast<double>(%s)' % value(x, scope, t)
	elif t=='real':
		return '(%s)' % value(x, scope, t);
	else:
		R(x, t)

def value_string(x, scope):
	if x['type']=='id':
		if not x['ref'][1:]:
			res=resolve_value(x['ref'][0], scope)
			if res['type']=='string':
				return '(%s)' % res['snip']
			elif res['type']=='value':
				return '(%s).cast_string()' % res['snip']
			elif res['type']=='int':
				return 'std::to_string(%s)' % res['snip']
			else:
				R(res)
		else:
			return 'self.wait(%s).cast_string()' \
				% ref1(x['ref'], scope)
	elif x['type']=='sconst':
		return 'std::string("%s")' % quote(x['value'])
	elif x['type']=='+':
		return '(' + ('+'.join( \
			['%s' % value_string(op, scope) \
			for op in x['operands']])) + ')'
	elif x['type']=='icast':
		return 'std::to_string(%s)' % value_int(x['expr'], scope)
	elif x['type']=='iconst':
		return 'std::string("%d")' % x['value'];
	else:
		R(x['type'], x)

def value_value(x, scope):
	if x['type']=='id':
		if not x['ref'][1:]:
			res=resolve_value(x['ref'][0], scope)
			if res['type']=='value':
				return res['snip']
			elif res['type']=='real':
				return 'DF(%s)' % res['snip']
			else:
				R(res)
		else:
			return 'self.wait(%s)' % ref1(x['ref'], scope)
	elif x['type'] in ['+', '-', '*', '/', '%', '<', '<=', '==',
			'!=', '>=', '>', '?:']:
		return '(%s)' % gen_formula(x, scope, 'value')
	else:
		R(x)

def value(x, scope, dest_type):
	if dest_type=='int':
		return value_int(x, scope)
	elif dest_type=='real':
		return value_real(x, scope)
	elif dest_type=='string':
		return value_string(x, scope)
	elif dest_type=='value':
		return value_value(x, scope)
	else:
		R(dest_type)

def ref1(r, scope):
	return resolve_id(r[0], scope) \
		+ ''.join(['[%s]' % value_int(x, scope) for x in r[1:]])

def gen_migrate(scope, ja):
	'''Must be in the beginning of the block'''
	res=''
	migrated_flag=False
	for r in ja.get('rules', []):
		rt=r['ruletype']
		rp=r.get('property')
		if rt=='expr' and rp=='locator_cyclic':
			assert not migrated_flag
			res+='\tif (self.migrate(CyclicLocator(%s))) {\n' \
				% value_int(r['expr'], scope)
			res+='\t\treturn MIGRATE;\n\t}\n\n'
			migrated_flag=True
	if not migrated_flag:
		if 'id' in ja:
			res+='\tif (self.migrate(%s)) {\n' \
				% locator(ja['id'], scope)
			res+='\t\treturn MIGRATE;\n\t}\n\n'
			migrated_flag=True
	if not migrated_flag:
		if DEFAULT_LOCATOR_0:
			res+='\tif (self.migrate(CyclicLocator(0))) {\n'
			res+='\t\treturn MIGRATE;\n\t}\n\n'
		else:
			raise Exception('Cannot migrate', ja.get('id'), ja['type'])

	return res

def gen_stealable(scope, ja):
	'''Generate check_steal'''
	the_code = ''
	for rule in ja.get('rules', []):
		if rule['ruletype'] == 'flags':
			subflags = rule.get('flags', [])
			if len(subflags) == 1 and subflags[0] == "stealable":
				the_code += '\t' + 'if (self.check_steal()) {' + '\n\t\t' + 'return STEAL;' + '\n\t' + '}' + '\n\n'
	return the_code

def parse_args(scope, ja):
	# bind names to sub arguments
	if ja['type']!='struct':
		return ''

	argc=0
	idc=0
	for i in range(len(ja['args'])):
		param=ja['args'][i]
		if param['type']=='name':
			scope['names'][param['id']]='self.id(%d)' % idc
			idc+=1
		elif param['type']=='int':
			scope['values'][param['id']]={
				'snip': 'self.arg(%d).get_int()' % argc,
				'type': 'int'
			}
			argc+=1
		elif param['type']=='real':
			scope['values'][param['id']]={
				'snip': 'self.arg(%d).get_real()' % argc,
				'type': 'real'
			}
			argc+=1
		elif param['type']=='string':
			scope['values'][param['id']]={
				'snip': 'self.arg(%d).get_string()' % argc,
				'type': 'string'
			}
			argc+=1
		elif param['type']=='value':
			scope['values'][param['id']]={
				'snip': 'self.arg(%d)' % argc,
				'type': 'value'
			}
			argc+=1
		else:
			R(param)
	return ''


def gen_exec_extern(scope, ja):
	assert ja['type']=='exec' and gja[ja['code']]['type']=='extern'

	cpp_head=''
	cpp_alloc_outs=''
	cpp_body=''
	cpp_afterstores=''
	cpp_tail=''

	sub=gja[ja['code']]
	cpp_head+='\t{\n'
	args=[]
	outs=[]

	assert len(ja['args'])==len(sub['args'])
	for i in range(len(ja['args'])):
		arg=ja['args'][i]
		param=sub['args'][i]['type']
		if param=='name':
			if 'begin' not in arg:
				pass # R(arg)
			out_ref=ref1(arg['ref'], scope)
			id='_out_%d' % len(outs)
			outs.append((id, out_ref, arg))
			args.append('\n\t\t\t// name %s\n\t\t\t%s' % (
				repr_expr(arg), id
			))
			cpp_alloc_outs+='\t\tDF %s;\n' % id
			if ADD_DEBUG_INFO:
				cpp_alloc_outs+='\t\t%s.DBG_INFO="name %s";\n' % (
					id, repr_expr(arg))
		elif param=='string':
			args.append('\n\t\t\t// %s %s\n\t\t\t%s.c_str()' % (
				param,
				repr_expr(arg),
				value(arg, scope, param)
			))
		else:
			args.append('\n\t\t\t// %s %s\n\t\t\t%s' % (
				param,
				repr_expr(arg),
				value(arg, scope, param)
			))
	cpp_body+='\t\t%s\n' % REM('EXEC_EXTERN ' + repr_exec(ja))
	cpp_body+='\t\t%s(' % sub['code']
	cpp_body+=', '.join(args)
	cpp_body+=');\n\n'

	for v, r, expr in outs:
		cpp_afterstores+='\t\t{\n'
		cpp_afterstores+='\t\t\tDF stored=%s;\n' % v
		if ADD_DEBUG_INFO:
			cpp_afterstores+='\t\t\tstored.DBG_INFO="value " + (%s).to_string();\n' % v

			cpp_afterstores+='\t\tif (stored.is_unset()) {\n'
			cpp_afterstores+='\t\t\tthrow RuntimeError(__FILE__, __LINE__,\n'
			cpp_afterstores+='\t\t\t\t"Output DF %s is left unset after %s");' \
				% (quote(repr_ref(expr['ref'])), quote(repr_ja(ja)))
			cpp_afterstores+='\t\t}\n'
		cpp_afterstores+='\t\t\tself.store(%s, stored);\n' % r
		cpp_afterstores+='\t\t}\n'
	cpp_tail+='\t}\n\n'

	return cpp_head+cpp_alloc_outs+cpp_body+cpp_afterstores+cpp_tail

def gen_exec_struct(scope, ja):
	assert ja['type']=='exec' and gja[ja['code']]['type']=='struct'

	sub=gja[ja['code']]
	res=''
	res+='\t{ %s\n' % REM('EXEC_STRUCT: ' + repr_exec(ja))
	res+='\t\tCF *child=self.fork(%s);\n' % get_sub_block(ja['code'])

	if ADD_DEBUG_INFO:
		res+='\t\tchild->DBG_INFO="%s";\n' % quote(repr_exec(ja))

	assert len(ja['args'])==len(sub['args'])
	argc, idc=0, 0
	for i in range(len(ja['args'])):
		arg=ja['args'][i]
		param=sub['args'][i]['type']
		if param=='name':
			res+='\t\tchild->id(%d)=%s;\n' \
				% (idc, ref1(arg['ref'], scope))
			idc+=1
		elif param=='int':
			res+='\t\tchild->arg(%d)=%s;\n' \
				% (argc, value_int(arg, scope))
			argc+=1
		elif param=='real':
			res+='\t\tchild->arg(%d)=%s;\n' \
				% (argc, value_real(arg, scope))
			argc+=1
		elif param=='string':
			res+='\t\tchild->arg(%d)=%s;\n' % (argc,
				value_string(arg, scope))
			argc+=1
		else:
			R(param, arg)
	res+='\t}\n\n'
	return res

def gen_afterstuff(scope, ja):
	res=''
	# Aftersets (indexed_setdfs)
	for r in ja.get('rules', []):
		rt=r['ruletype']
		rp=r.get('property')
		if rt=='indexed_setdfs':
			for df in r['dfs']:
				res+='\t{\n'
				if VERBOSE:
					res+='\t\tprintf("isetdf >> %s: %%s\\n", %s.to_string().c_str());\n' % (repr_ref(df['ref']), ref1(df['ref'], scope))
				res+='\t\tDF one; one=1;\n'
				if ADD_DEBUG_INFO:
					res+='\t\tone.DBG_INFO="setdf:%s";\n' \
						% repr_ref(df['ref'])
				res+='\t\tself.store(%s, one);\n' % (
					ref1(df['ref'], scope)
				)
				res+='\t}\n'
	# Posts, deletes, pushes
	for r in ja.get('rules', []):
		rt=r['ruletype']
		rp=r.get('property')
		if rt=='assign' and rp=='req_count':
			res+='\t%s\n' % REM(repr_rule(r))
			res+='\t{\t\tDF posted=%s;\n' % \
				'self.wait(%s)' % ref1(r['id'], scope)
			if ADD_DEBUG_INFO:
				res+='\t\tposted.DBG_INFO+="value_of:%s";\n' \
					% repr_ref(r['id'])
			res+='\t\tself.post(%s, posted, %s, %s);\n\t}\n' % (
				ref1(r['id'], scope),
				locator(r['id'], scope),
				value_int(r['val'], scope)
			)
		elif rt=='enum' and rp=='req_unlimited':
			for it in r['items']:
				res+='\t%s\n' % REM('req_unlimited: %s' % repr_ref(it))

				res+='\t{\t\tDF posted=%s;\n' % \
					'self.wait(%s)' % ref1(it, scope)
				if ADD_DEBUG_INFO:
					res+='\t\tposted.DBG_INFO+="value_of:%s";\n' \
						% repr_ref(it)

				res+='\tself.post(%s, posted, %s, -1);\n\t}\n' % (
					ref1(it, scope),
					locator(it, scope)
				)
		elif rt=='enum' and rp=='delete':
			for it in r['items']:
				if VERBOSE:
					res+='\tprintf("DELETE %s: %%s\\n", (%s).to_string().c_str());\n' % (repr_ref(it), ref1(it, scope))
				res+='\tself.destroy(%s, %s);\n' % (
					ref1(it, scope),
					locator(it, scope)
				)
		elif rt=='map' and rp=='afterpush':
			assert r['expr']['type']=='id'
			res+='\tself.push(%s, %s, %s, %s);\n' % (
				ref1(r['id'], scope),
				'self.wait(%s)' % ref1(r['id'], scope),
				ref1(r['expr']['ref'], scope),
				locator(r['expr']['ref'], scope)
			)
		elif rt=='indexed':
			for df in r['dfs']:
				if VERBOSE:
					res+='\tprintf("DELETE %s: %%s\\n", (%s).to_string().c_str());\n' % (repr_ref(df['ref']), ref1(df['ref'], scope))
				res+='\tself.destroy(%s, %s);\n' % (
					ref1(df['ref'], scope),
					locator(df['ref'], scope)
				)
	return res


def parse_ids(scope, ja):
	if 'body' in ja:
		for bi in ja['body']:
			if bi['type']=='dfs':
				for df in bi['names']:
					scope['dfs'].append(df)
			else:
				if 'id' in bi:
					scope['cfs'].append(bi['id'][0])

def gen_create_ids(scope, ja):
	create_ids=''
	for id, comment in scope['create_ids']:
		create_ids+='\tId %s=self.create_id(); // %s\n' % (id, comment)
		if ADD_DEBUG_INFO:
			'\t%s.DBG_INFO="name:%s";\n' % (id, comment)
		if VERBOSE:
			create_ids+='\tprintf("Created id for ' + comment \
				+ ': %s\\n", ' + id + '.to_string().c_str());\n'
	create_ids+='\n'
	return create_ids

def gen_requests_preliminary(scope, ja, next_block_info):
	'''Can breake the block. Starts and ends in open blocks'''
	requests=''

	rw_rules=[]
	for r in ja.get('rules', []):
		if r['ruletype']=='enum' and r['property']=='request_preliminary':
			rw_rules.append(r)

	# Requests
	for r in ja.get('rules', []):
		rt=r['ruletype']
		rp=r.get('property')
		if rt=='enum' and rp=='request_preliminary':
			for it in r['items']:
				requests+='\t%s\n' % REM('request_preliminary %s' % repr_ref(it))
				if VERBOSE:
					requests+='\tprintf("Requesting ' \
						+ '%s: %%s\\n", (%s).to_string().c_str());\n'\
						% (repr_ref(it), ref1(it, scope))
				requests+='\tself.request(%s, %s);\n' % (ref1(it, scope),
					locator(it, scope))
			bid=gen_id(r['begin'], repr_rule(r))
			requests+='\n\tself.NextBlock=%d;\n' % bid
			requests+='\treturn CONTINUE;\n'
			requests+='}\n\n'
			requests+=BLOCKH % ('RequestPreliminary : %s' % repr_ja(ja), bid)
			for it in r['items']:
				requests+='\t%s\n' % REM('wait %s' % repr_ref(it))
				requests+='\tif (self.wait(%s).is_unset()) {\n' \
					% ref1(it, scope)
				if VERBOSE:
					requests+='\t\tprintf("Awaiting missing %s: %%s\\n", ' \
						% repr_ref(it) + '(%s).to_string().c_str());\n' \
						% ref1(it, scope)
				requests+='\t\treturn WAIT;\n'
				requests+='\t}\n\n'
			assert rw_rules[0]==r
			rw_rules.pop(0)
			if rw_rules:
				bid=gen_id(rw_rules[0]['begin'],
					'pass to next rule: %s' % repr_rule(rw_rules[0]))
			else:
				bid=gen_id(next_block_info['pos'],
					next_block_info.get('comment', ''))
			requests+='\n\tself.NextBlock=%d;\n' % bid
			requests+='\treturn CONTINUE;\n'
			requests+='}\n\n'
			requests+=BLOCKH % ('After requests: %s' % repr_ja(ja), bid)

	assert not rw_rules

	return requests

def gen_requests(scope, ja, next_block_info):
	'''Can breake the block. Starts and ends in open blocks'''
	requests=''

	rw_rules=[]
	for r in ja.get('rules', []):
		if r['ruletype']=='enum' and r['property']=='request':
			rw_rules.append(r)
	for r in ja.get('rules', []):
		if r['ruletype']=='enum' and r['property']=='wait':
			rw_rules.append(r)


	# Requests
	for r in ja.get('rules', []):
		rt=r['ruletype']
		rp=r.get('property')
		if rt=='enum' and rp=='request':
			for it in r['items']:
				requests+='\t%s\n' % REM('request %s' % repr_ref(it))
				if VERBOSE:
					requests+='\tprintf("Requesting ' \
						+ '%s: %%s\\n", (%s).to_string().c_str());\n'\
						% (repr_ref(it), ref1(it, scope))
				requests+='\tself.request(%s, %s);\n' % (ref1(it, scope),
					locator(it, scope))
			bid=gen_id(r['begin'], repr_rule(r))
			requests+='\n\tself.NextBlock=%d;\n' % bid
			requests+='\treturn CONTINUE;\n'
			requests+='}\n\n'
			requests+=BLOCKH % ('Request : %s' % repr_ja(ja), bid)
			for it in r['items']:
				requests+='\t%s\n' % REM('wait %s' % repr_ref(it))
				requests+='\tif (self.wait(%s).is_unset()) {\n' \
					% ref1(it, scope)
				if VERBOSE:
					requests+='\t\tprintf("Awaiting missing %s: %%s\\n", ' \
						% repr_ref(it) + '(%s).to_string().c_str());\n' \
						% ref1(it, scope)
				requests+='\t\treturn WAIT;\n'
				requests+='\t}\n\n'
			assert rw_rules[0]==r
			rw_rules.pop(0)
			if rw_rules:
				bid=gen_id(rw_rules[0]['begin'],
					'pass to next rule: %s' % repr_rule(rw_rules[0]))
			else:
				bid=gen_id(next_block_info['pos'],
					next_block_info.get('comment', ''))
			requests+='\n\tself.NextBlock=%d;\n' % bid
			requests+='\treturn CONTINUE;\n'
			requests+='}\n\n'
			requests+=BLOCKH % ('After requests: %s' % repr_ja(ja), bid)

	waits=''
	# Waits (explicit)
	has_waits=False
	for r in ja.get('rules', []):
		rt=r['ruletype']
		rp=r.get('property')
		if rt=='enum' and rp=='wait':
			has_waits=True
			bid=gen_id(r['begin'], repr_rule(r))
			waits+='\n\tself.NextBlock=%d;\n' % bid
			waits+='\treturn CONTINUE;\n'
			waits+='}\n\n'
			waits+=BLOCKH % ('Explicit waits: %s' % repr_ja(ja), bid)
			for it in r['items']:
				waits+='\tif (self.wait(%s).is_unset()) {\n' \
					% ref1(it, scope)
				if VERBOSE:
					waits+='\t\tprintf("Awaiting missing %s: %%s\\n", ' \
						% repr_ref(it) + '%s.to_string().c_str());\n' \
						% ref1(it, scope)
				waits+='\t\treturn WAIT;\n'
				waits+='\t}\n\n'
			assert rw_rules[0]==r
			rw_rules.pop(0)
			if rw_rules:
				bid=gen_id(rw_rules[0]['begin'],
					'pass to next rule: %s' % repr_rule(rw_rules[0]))
			else:
				bid=gen_id(next_block_info['pos'],
					next_block_info.get('comment', ''))
			waits+='\n\tself.NextBlock=%d;\n' % bid
			waits+='\treturn CONTINUE;\n'
			waits+='}\n\n'
			waits+=BLOCKH % ('After explicit waits: %s' % repr_ja(ja), bid)
	expect=''
	if has_waits:
		expect+='\tself.expect_pushes(%s);\n\n' % ref1(ja['id'], scope)

	assert not rw_rules

	return expect+requests+waits

def gen_bi_exec(ja, parent_scope):
	# { migrate} {xp/req}{wait} {exec; afterstuff}
	scope=create_scope(ja, parent_scope)
	bid=gen_id(ja['begin'], 'entry (migrate) %s' % repr_bi(ja))

	cpp=''
	cpp+=BLOCKH % ('BI_EXEC: %s' % repr_ja(ja), bid)
	cpp+=gen_requests_preliminary(scope, ja, {
		'pos': ja['begin'],
		'comment': 'migrate'
	})
	cpp+=gen_migrate(scope, ja)
	cpp+=gen_stealable(scope, ja)
	cpp+=gen_requests(scope, ja, {
		'pos': ja['begin'],
		'comment': 'execute %s' % repr_ja(ja)
	})

	if gja[ja['code']]['type']=='struct':
		cpp+=gen_exec_struct(scope, ja)
	elif gja[ja['code']]['type']=='extern':
		cpp+=gen_exec_extern(scope, ja)
	else:
		R()

	cpp+=gen_afterstuff(scope, ja)

	cpp+='\treturn EXIT;\n'
	cpp+='}\n\n'

	return bid, cpp

def gen_bi_for(ja, parent_scope):
	assert ja['type']=='for'
	scope=create_scope(ja, parent_scope)
	bid=gen_id(ja['begin'], 'entry (migrate) %s' % repr_bi(ja))

	cpp=''
	cpp+=BLOCKH % ('BI_FOR: %s' % repr_ja(ja), bid)
	cpp+=gen_requests_preliminary(scope, ja, {
		'pos': ja['begin'],
		'comment': 'migrate'
	})
	cpp+=gen_migrate(scope, ja)
	cpp+=gen_requests(scope, ja, {
		'pos': ja['body_begin'],
		'comment': 'body fork: %s' % repr_ja(ja)
	})

	old_values=json.dumps(scope['values'])

	scope['values'][ja['var']]={
		'snip': '_lc_%s' % ja['var'],
		'type': 'int'
	}

	cpp_bodyfork, cpp_bodyitems=gen_body(scope, ja)

	cpp+='\tfor (int %s=%s; %s<=%s; %s++) {\n' % (
		'_lc_%s' % ja['var'],
		value_int(ja['first'], scope),
		'_lc_%s' % ja['var'],
		value_int(ja['last'], scope),
		'_lc_%s' % ja['var']
	)
	cpp+=cpp_bodyfork
	cpp+='\t} // for\n'

	scope['values']=json.loads(old_values)

	cpp+=gen_afterstuff(scope, ja)

	cpp+='\treturn EXIT;\n'
	cpp+='}\n\n'
	cpp+=cpp_bodyitems

	return bid, cpp

def gen_bi_while(ja, parent_scope):
	assert ja['type']=='while'
	scope=create_scope(ja, parent_scope)
	bid=gen_id(ja['init_begin'], 'entry (set counter) %s' \
		% repr_bi(ja))

	cpp=''
	cpp+=BLOCKH % ('BI_WHILE: init counter: %s' % repr_ja(ja), bid)
	arg_num=len(scope['args'])
	scope['values'][ja['var']]={
		'snip': 'self.arg(%d).get_int()' % arg_num,
		'type': 'int'
	}
	scope['args'].append(None)
	cpp+='\tself.arg(%d)=(%s);\n' %  (
		arg_num,
		value_int(ja['start'], scope)
	)
	next_bid=gen_id(ja['begin'], 'migrate: %s' % repr_ja(ja))
	cpp+='\tself.NextBlock=%d;\n' % next_bid
	cpp+='\treturn CONTINUE;\n'
	cpp+='}\n\n'
	cpp+=BLOCKH % ('WHILE: preparations: %s' % repr_ja(ja), next_bid)
	cpp+=gen_requests_preliminary(scope, ja, {
		'pos': ja['begin'],
		'comment': 'migrate'
	})
	cpp+=gen_migrate(scope, ja)
	cpp+=gen_requests(scope, ja, {
		'pos': ja['body_begin'],
		'comment': 'body fork: %s' % repr_ja(ja)
	})

	cpp_bodyfork, cpp_bodyitems=gen_body(scope, ja)
	cpp+='\tif (0 != %s) {\n' % value_int(ja['cond'], scope)
	cpp+=cpp_bodyfork
	cpp+='\tself.arg(%d)=(%s)+1;\n' % (
		arg_num,
		scope['values'][ja['var']]['snip']
	)
	cpp+='\tself.NextBlock=%d;\n' % next_bid
	cpp+='\treturn CONTINUE; // next while iter\n'
	cpp+='\t} else { // while\n'
	cpp+='\t\tself.store(%s, self.arg(%d)); // set wout\n' % (
		ref1(ja['wout']['ref'], scope),
		arg_num
	)
	cpp+=gen_afterstuff(scope, ja)
	cpp+='\t} // while\n'
	cpp+='\treturn EXIT;\n'
	cpp+='}\n\n'
	cpp+=cpp_bodyitems

	return bid, cpp

def gen_bi_if(ja, parent_scope):
	assert ja['type']=='if'
	scope=create_scope(ja, parent_scope)
	bid=gen_id(ja['begin'], 'migrate: %s' % repr_ja(ja))

	cpp=''
	cpp+=BLOCKH % ('IF: preparations: %s' % repr_ja(ja), bid)
	cpp+=gen_requests_preliminary(scope, ja, {
		'pos': ja['begin'],
		'comment': 'migrate'
	})
	cpp+=gen_migrate(scope, ja)
	cpp+=gen_requests(scope, ja, {
		'pos': ja['body_begin'],
		'comment': 'body fork: %s' % repr_ja(ja)
	})

	cpp_bodyfork, cpp_bodyitems=gen_body(scope, ja)

	cpp+='\tif (0!=%s) {\n' % value_int(ja['cond'], scope)
	cpp+=cpp_bodyfork
	cpp+='\t} // if\n'

	cpp+=gen_afterstuff(scope, ja)

	cpp+='\treturn EXIT;\n'
	cpp+='}\n\n'
	cpp+=cpp_bodyitems

	return bid, cpp

def gen_bi(ja, parent_scope):
	if ja['type']=='exec':
		return gen_bi_exec(ja, parent_scope)
	elif ja['type']=='for':
		return gen_bi_for(ja, parent_scope)
	elif ja['type']=='while':
		return gen_bi_while(ja, parent_scope)
	elif ja['type']=='if':
		return gen_bi_if(ja, parent_scope)
	else:
		R(ja['type'])

	return bi_bid, cpp

def gen_body(scope, ja):
	assert 'body' in ja

	items=''
	forks='// GEN BODY: %s\n' % repr_ja(ja)
	parse_ids(scope, ja)

	for bi in ja['body']:
		if bi['type']!='dfs':
			bibid, cpp=gen_bi(bi, scope)

			items+=cpp

			forks+='\t{ %s\n' % REM('FORK_BI: ' + repr_bi(bi))
			forks+='\t\tCF *child=self.fork(%d);\n' % bibid
			if ADD_DEBUG_INFO:
				forks+='\t\tchild->DBG_INFO="fork:%s";\n' % quote(repr_bi(bi))
			# push args and fork
			for i in range(len(scope['children'][-1]['args'])):
				arg=scope['children'][-1]['args'][i]
				if arg is not None:
					forks+='\t\tchild->arg(%d)=%s;\n' \
						% (i, arg)
				else:
					forks+='\t\tchild->arg(%d); // uninitialized\n' % i
			for i in range(len(scope['children'][-1]['ids'])):
				id=scope['children'][-1]['ids'][i]
				assert id is not None
				forks+='\t\tchild->id(%d)=%s;\n' \
					% (i, id)
			forks+='\t}\n\n'

	forks=gen_create_ids(scope, ja)+forks
	return forks, items

def gen_struct(ja):
	assert ja['type']=='struct' and 'name' in ja
	scope=create_scope(ja, None)
	# (sub_params) {create_ids; fork; exit} {bi}{bi}{bi}
	scope['bid']=get_sub_block(ja['name'])
	parse_args(scope, ja)
	parse_ids(scope, ja)

	cpp_bodyfork, cpp_bodyitems=gen_body(scope, ja)

	cpp=''
	cpp+=BLOCKH % ('STRUCT: %s' % repr_ja(ja), scope['bid'])
#	cpp+=gen_create_ids(scope, ja)
	cpp+=cpp_bodyfork
	cpp+='\treturn EXIT;\n'
	cpp+='}\n\n'
	cpp+=cpp_bodyitems

	return scope['bid'], cpp


def parse_import(ja):
	return 'extern "C" void %s(%s); // as %s\n' % (ja['code'],
		', '.join([C_TYPE[x['type']] for x in ja['args']]), ja['name'])

if __name__=='__main__':
	if '--help' in sys.argv[1:]:
		print(HELP_MESSAGE)
		sys.exit(0)
	if len(sys.argv[1:])<3:
		sys.stderr.write('%s: invalid arguments count, see --help\n' \
			% _prog)
		sys.exit(1)

	try:
		for arg in sys.argv[4:]:
			if arg=='--add-debug-info':
				ADD_DEBUG_INFO=True
			else:
				sys.stderr.write("%s: key not recognized: '%s', see --help\n"\
					% (_prog, arg))
				sys.exit(1)

		gja=json.loads(open(sys.argv[1]).read())
		gja['main']['name']='main'
		main_id=gen_id(gja['main']['begin'],
			'initial launcher: %s' % repr_ja(gja['main']))
		del gja['main']['name']
		head='#include "ucenv.h"\n\n'
		mid=''
		body=''
		tail=''

		mid+=BLOCKH % ('MAIN', main_id)


		for name, sub in gja.items():
			assert 'name' not in sub
			sub['name']=name

			if sub['type']=='extern':
				head+=parse_import(sub)
				if name=='main':
					mid+='\t%s\n' % REM('EXEC_EXTERN')
					mid+='\t%s(' % sub['code']
					args=[]
					for i in range(len(sub['args'])):
						args.append('self.arg(%d)' % i)
					mid+=', '.join(args)
					mid+=');\n\n'
					mid+='\treturn EXIT;\n'

				continue

			bid, cpp=gen_struct(sub)

			body+=cpp

			if name=='main':
				for i in range(len(sub['args'])):
					mid+='self.arg(%d)=self.argv(%s, %d);\n' % (i,
						C_VALUE_TYPE[sub['args'][i]['type']], i)
				mid+='\n'
				mid+='\tself.NextBlock=%d;\n' % bid
				mid+='\treturn CONTINUE;\n'
		head+='\n'

		mid+='}\n\n'



		if gid<200:
			tail='extern "C" void init_blocks(BlocksAppender add)\n{\n'
			tail+='\tbool ok=true;\n\n'
			for i in range(gid):
				tail+='\tok = ok && add(block_%d)==%d;\n' % (i, i)
			tail+='\n\tassert(ok);\n}\n\n'

			res=head+mid+body+tail
			open(sys.argv[2], 'w').write(res)
		else:
			blocks_count=0
			chunk_size=0
			chunk_num=0
			chunk=[]
			chunk_ids=[]
			for ln in (mid+body).split('\n'):
				if ln.startswith('BlockRetStatus block_'):
					assert ln.endswith('(CF &self)')
					block_id=int(ln[len('BlockRetStatus block_'):\
						-len('(CF &self)')])
					assert block_id not in chunk_ids
					chunk_ids.append(block_id)
					blocks_count+=1
					chunk_size+=1

				if chunk_size>=100:
					chunk_size=0
					chunk_ids=[chunk_ids[-1]]
					open('%s_%04X.cpp' % (sys.argv[2], chunk_num), 'w').write(head+
						('\n'.join(chunk))+tail)
					chunk_num+=1
					chunk=[]

				chunk.append(ln)
			if chunk:
				chunk_ids=[]
				open('%s_%04X.cpp' % (sys.argv[2], chunk_num), 'w').write(head+
					('\n'.join(chunk))+tail)
				chunk_num+=1
				tail=''
			tail='extern "C" void init_blocks(BlocksAppender add)\n{\n'
			other_head='#include "ucenv.h"\n\n'
			CHUNK_SIZE=100
			chunks=[]
			chunk_num=0
			for id in range(blocks_count):
				if id % CHUNK_SIZE==0:
					if chunks:
						chunks[-1].append('\n\tassert(ok);\n}\n')
					chunks.append(['void init_chunk_%d(BlocksAppender add)\n' % chunk_num])
					chunks[-1].append('{\n\t\tbool ok=true;\n\n')
					chunk_num+=1
				other_head+='BlockRetStatus block_%d(CF &);\n' % id
				chunks[-1].append('\tok=ok && (add(block_%d)==%d);\n' % (id, id))
			chunks[-1].append('\n\tassert(ok);\n}\n')

			for i in range(chunk_num):
				tail+='\t\tinit_chunk_%d(add);\n' % i
				other_head+=''.join(chunks[i])

			tail+='}\n\n'

			open(sys.argv[2], 'w').write(other_head+tail);

			if blocks_count!=gid:
				R(blocks_count, gid)

		open(sys.argv[3], 'w').write(json.dumps(cpp_blocks_info, indent=4))
	except CompileError as x:
		sys.stderr.write('#ERROR at %d: %s\n' % (x.Pos, x.Msg))
		sys.exit(1)
